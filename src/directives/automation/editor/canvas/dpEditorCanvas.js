(function () {
  'use strict';

  angular
    .module('dopplerApp.automation.editor')
    .directive('dpEditorCanvas', dpEditorCanvas);

  dpEditorCanvas.$inject = [
    'automation',
    'AUTOMATION_STATE',
    'CHANGE_TYPE',
    'changesManager',
    'COMPONENT_TYPE',
    'selectedElementsService',
    'warningsStepsService',
    'goToService',
  ];

  function dpEditorCanvas(
    automation,
    AUTOMATION_STATE,
    CHANGE_TYPE,
    changesManager,
    COMPONENT_TYPE,
    selectedElementsService,
    warningsStepsService,
    goToService
  ) {
    var directive = {
      restrict: 'E',
      templateUrl:
        'angularjs/partials/automation/editor/directives/canvas/dp-editor-canvas.html',
      controller: ['$scope', controller],
      link: link,
    };

    return directive;

    function controller($scope) {
      var watchsCollection = [];
      $scope.AUTOMATION_STATE = AUTOMATION_STATE;
      $scope.rootComponent = automation.getModel();
      $scope.isReadOnly = automation.isReadOnly;
      $scope.isPaused = automation.isPaused;

      if (
        $scope.rootComponent.initialCondition &&
        !$scope.rootComponent.initialCondition.completed
      ) {
        selectedElementsService.setSelectedComponent(
          $scope.rootComponent.initialCondition
        );
      }

      $scope.$watch(
        selectedElementsService.getSelectedComponent,
        function (newComponent, oldComponent) {
          if (!newComponent) {
            goToService.unmarkAllComponentsInGotoSelection([
              'goto-target-available',
              'goto-target-unavailable',
              'goto-connected',
              'goto-possible-connection',
              'dp-tooltip-container',
            ]);
          }

          if (watchsCollection.length && newComponent !== oldComponent) {
            removeWatchs();
          }

          if (newComponent) {
            addAutogeneratedPushName(newComponent);
            if (oldComponent && oldComponent.uid !== newComponent.uid) {
              setTouchedComponent(oldComponent);
              addAutogeneratedEmailIdName(oldComponent);
              addAutogeneratedSmsName(oldComponent);
            }
            if (
              newComponent.type === COMPONENT_TYPE.SMS &&
              !newComponent.name
            ) {
              addAutogeneratedSmsName(newComponent);
            }

            $scope.selectedComponent = newComponent;
            watchSelectedComponentProperties();
          } else if ($scope.selectedComponent) {
            setTouchedComponent($scope.selectedComponent);
            addAutogeneratedEmailIdName($scope.selectedComponent);
            addAutogeneratedSmsName($scope.selectedComponent);
            $scope.selectedComponent = null;
          }
        }
      );

      function setTouchedComponent(component) {
        if (!component.touched) {
          component.touched = true;
        }
      }

      function addAutogeneratedSmsName(component) {
        if (component.type === COMPONENT_TYPE.SMS && !component.name) {
          var oldComponentData;
          var newComponentData;
          if (!automation.getComponentByUid(component.uid)) {
            return;
          }
          var newSmsIdName = parseInt($scope.rootComponent.lastSmsIdName) || 0;
          newSmsIdName = ++newSmsIdName;
          var newSmsName = 'SMS_' + newSmsIdName;

          oldComponentData = '';
          newComponentData = newSmsIdName;
          component.setData({
            hasUnsavedChanges: true,
            name: newSmsName,
          });

          changesManager.add({
            type: CHANGE_TYPE.PROPERTY,
            uid: component.uid,
            key: 'name',
            oldValue: angular.copy(oldComponentData),
            newValue: angular.copy(newComponentData),
          });

          $scope.rootComponent.lastSmsIdName = newSmsIdName;
          component.checkCompleted();
          warningsStepsService.checkWarningStep(component);
          automation.checkCompleted();
        }
      }

      function addAutogeneratedPushName(component) {
        if (
          component &&
          component.type === COMPONENT_TYPE.PUSH_NOTIFICATION &&
          !component.name
        ) {
          var oldComponentData;
          var newComponentData;
          if (!automation.getComponentByUid(component.uid)) {
            return;
          }
          var newPushIdName = parseInt(component.uid) || 0;
          var newPushName = 'Push_' + newPushIdName;

          oldComponentData = '';
          newComponentData = newPushName;
          component.setData({
            hasUnsavedChanges: true,
            name: newPushName,
          });

          changesManager.add({
            type: CHANGE_TYPE.PROPERTY,
            uid: component.uid,
            key: 'name',
            oldValue: angular.copy(oldComponentData),
            newValue: angular.copy(newComponentData),
          });

          component.checkCompleted();
          warningsStepsService.checkWarningStep(component);
          automation.checkCompleted();
        }
      }

      function addAutogeneratedEmailIdName(component) {
        if (component.type === COMPONENT_TYPE.CAMPAIGN && !component.name) {
          var newEmailName;
          var newEmailIdName;
          var oldComponentData;
          var newComponentData;

          //we need to check if the email component still exists
          if (!automation.getComponentByUid(component.uid)) {
            return;
          }
          newEmailIdName = ++$scope.rootComponent.lastEmailIdName;
          newEmailName = 'Email_' + newEmailIdName;

          oldComponentData = '';
          newComponentData = newEmailName;
          component.setData({
            hasUnsavedChanges: true,
            name: newEmailName,
          });

          changesManager.add({
            type: CHANGE_TYPE.PROPERTY,
            uid: component.uid,
            key: 'name',
            oldValue: angular.copy(oldComponentData),
            newValue: angular.copy(newComponentData),
            callback: automation.onEmailNameChange,
          });

          $scope.rootComponent.lastEmailIdName = newEmailIdName;
          automation.onEmailNameChange(component.uid, newEmailName);
          component.checkCompleted();
          warningsStepsService.checkWarningStep(component);
          automation.checkCompleted();
        }
      }

      function getUrlWithoutParams(url) {
        var questionMarkIndex = url.indexOf('?');
        if (questionMarkIndex === -1) {
          return url;
        }
        return url.slice(0, questionMarkIndex);
      }

      function watchSelectedComponentProperties() {
        $scope.selectedComponentUid = $scope.selectedComponent
          ? $scope.selectedComponent.uid
          : -1;

        var propertiesToWatch = $scope.selectedComponent.getPropertiesToWatch();
        propertiesToWatch.forEach(function (property) {
          var watch = $scope.$watch(
            function () {
              return _.get($scope.selectedComponent, property);
            },
            function (newValue, oldValue) {
              if (
                newValue === oldValue ||
                changesManager.isChanging() ||
                !changesManager.isEnabled()
              ) {
                return;
              }

              // Fix related to https://makingsense.atlassian.net/browse/DOP-1027
              // Compare thumbnailUrl's without consider the url param.
              // This param value is generated using "$timeout" on each 1000ms in the dpEditorCampaign.js.
              if (property === 'thumbnailUrl') {
                var oldUrlWithoutParams = getUrlWithoutParams(oldValue);
                var newUrlWithoutParams = getUrlWithoutParams(newValue);
                if (newUrlWithoutParams === oldUrlWithoutParams) {
                  return;
                }
              }

              changesManager.add({
                type: CHANGE_TYPE.PROPERTY,
                uid: $scope.selectedComponent.uid,
                key: property,
                oldValue: angular.copy(oldValue),
                newValue: angular.copy(newValue),
              });
              //we need to put the flag in true to update the campaign or delay in the next saving process
              if (
                $scope.selectedComponent.type === COMPONENT_TYPE.CAMPAIGN ||
                $scope.selectedComponent.type === COMPONENT_TYPE.DELAY
              ) {
                $scope.selectedComponent.hasUnsavedChanges = true;
              }
              $scope.selectedComponent.checkCompleted();
              automation.checkCompleted();
              warningsStepsService.checkWarningStep($scope.selectedComponent);
            },
            true
          );
          watchsCollection.push(watch);
        });
      }

      function removeWatchs() {
        watchsCollection.forEach(function (removeWatch) {
          removeWatch();
        });
        watchsCollection.length = 0;
      }
    }

    function link(scope, element) {
      scope.$on('COMPONENTS_LIST:HIDE', function () {
        var showStepsElements = angular.element(
          document.querySelector('.add-step-type--container:not(.ng-hide)')
        );
        if (showStepsElements.length) {
          showStepsElements.scope().showStepOptions = false;
        }
      });

      scope.$on('ALTERING_CONDITION_FINISHED', function () {
        setTimeout(function () {
          goToService.regenerateGotoLinesFromComponentsRegistration();
        }, 100);
      });

      element.ready(function () {
        element[0].addEventListener('scroll', function () {
          goToService.updateLinePosition();
        });
        new ResizeObserver(goToService.updateLinePosition).observe(element[0]);
      });
    }
  }
})();
